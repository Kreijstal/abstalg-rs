// Copyright (C) 2020 Miklos Maroti
// Licensed under the MIT license (see LICENSE)

use crate::*;

/// The 2-element field represented as residue classes of integers modulo 2.
pub const GF2: QuotientField<CheckedInts<i8>> = QuotientField {
    base: I8,
    modulo: 2,
};

/// The 3-element field represented as residue classes of integers modulo 3.
pub const GF3: QuotientField<CheckedInts<i8>> = QuotientField {
    base: I8,
    modulo: 3,
};

/// A quotient field of an Euclidean domain by a principal ideal
/// generated by an irreducible (prime) element.
#[derive(Clone, Debug)]
pub struct QuotientField<R>
where
    R: EuclideanDomain,
{
    base: R,
    modulo: R::Elem,
}

impl<R> QuotientField<R>
where
    R: EuclideanDomain,
{
    /// Creates a field from the given Euclidean domain and one of
    /// its irreducible (prime) element. This method does not check
    /// that the modulo is indeed irreducible. If this fails, then
    /// calculating the multiplicative inverse of some elements
    /// may panic.
    pub fn new(base: R, modulo: R::Elem) -> Self {
        assert!(base.contains(&modulo));
        let one = base.one();
        assert!(base.is_zero(&base.rem(&one, &one)));
        QuotientField { base, modulo }
    }

    /// Returns the base ring from which this field was constructed.
    pub fn base(&self) -> &R {
        &self.base
    }

    /// Returns the modulo element from which this field was constructed.
    pub fn modulo(&self) -> &R::Elem {
        &self.modulo
    }
}

impl<R> Domain for QuotientField<R>
where
    R: EuclideanDomain,
{
    type Elem = R::Elem;

    fn contains(&self, elem: &Self::Elem) -> bool {
        self.base.reduced(elem, &self.modulo)
    }

    fn equals(&self, elem1: &Self::Elem, elem2: &Self::Elem) -> bool {
        self.base.equals(elem1, elem2)
    }
}

impl<R> Semigroup for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn mul(&self, elem1: &Self::Elem, elem2: &Self::Elem) -> Self::Elem {
        self.base.rem(&self.base.mul(elem1, elem2), &self.modulo)
    }
}

impl<R> Monoid for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn one(&self) -> Self::Elem {
        self.base.one()
    }

    fn is_one(&self, elem: &Self::Elem) -> bool {
        self.base.is_one(elem)
    }

    fn try_inv(&self, elem: &Self::Elem) -> Option<Self::Elem> {
        if self.is_zero(elem) {
            None
        } else {
            Some(self.inv(elem))
        }
    }

    fn invertible(&self, elem: &Self::Elem) -> bool {
        !self.is_zero(elem)
    }
}

impl<R> AbelianGroup for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn zero(&self) -> Self::Elem {
        self.base.zero()
    }

    fn neg(&self, elem: &Self::Elem) -> Self::Elem {
        self.base.rem(&self.base.neg(elem), &self.modulo)
    }

    fn add(&self, elem1: &Self::Elem, elem2: &Self::Elem) -> Self::Elem {
        self.base.rem(&self.base.add(elem1, elem2), &self.modulo)
    }
}

impl<R> UnitaryRing for QuotientField<R> where R: EuclideanDomain {}

impl<R> IntegralDomain for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn try_div(&self, elem1: &Self::Elem, elem2: &Self::Elem) -> Option<Self::Elem> {
        self.auto_try_div(elem1, elem2)
    }

    fn associate_repr(&self, elem: &Self::Elem) -> Self::Elem {
        self.auto_associate_repr(elem)
    }

    fn associate_coef(&self, elem: &Self::Elem) -> Self::Elem {
        self.auto_associate_coef(elem)
    }
}

impl<R> EuclideanDomain for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn quo_rem(&self, elem1: &Self::Elem, elem2: &Self::Elem) -> (Self::Elem, Self::Elem) {
        self.auto_quo_rem(elem1, elem2)
    }
}

impl<R> Field for QuotientField<R>
where
    R: EuclideanDomain,
{
    fn inv(&self, elem: &Self::Elem) -> Self::Elem {
        assert!(!self.is_zero(elem));
        let (g, _, r) = self.base.extended_gcd(&self.modulo, elem);
        let a = self.base.try_inv(&g).expect("modulo was not irreducible");
        println!("{:?}, {:?}, {:?}", g, r, a);
        self.mul(&a, &r)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn field_1721() {
        let field = QuotientField::new(I32, 1721);

        for a in 0..1720 {
            assert!(field.contains(&a));
            if a != 0 {
                let b = field.inv(&a);
                assert!(field.contains(&b));
                println!("{} {}", a, b);
                assert!(field.is_one(&field.mul(&a, &b)));
            }
        }
    }
}
